[step_1]
label = "ACP Integration"
content = """
First-class support for the Agent Client Protocol (ACP):

- Integrate directly into IDEs like Zed, VS Code, and others
- Wrap external agents (Claude Code, Goose, Codex, fast-agent) as nodes
- Unified node abstraction - ACP agents work like native agents
- Compose ACP agents into teams with native agents
- Use any ACP agent as a tool for other agents
- Session management and conversation history
- File system and terminal operations with permission handling
"""

[step_2]
label = "Easy Agent Configuration"
content = """
AgentPool excels at static YAML-based agent configuration:

- Define agents with unprecedented detail in pure YAML (Pydantic-backed)
- Expansive JSON schema for IDE autocompletion and validation
- Agent "connection" setup via YAML enabling workflows without step-based code
- Result type definitions via YAML
- Configuration inheritance and reuse
- Environment/tools/resource configuration
- Type-safe structured responses
"""

[step_3]
label = "True Async Framework"
content = """
An async-first Agent framework.
Unlike most other frameworks where async only happens at workflow-step level,
this framework is async-first in its design.

- Proper async context management
- Non-blocking operations
- Streaming responses
- Resource cleanup
- Background task handling
- Parallel initialization
- Automatic resource management
"""

[step_4]
label = "Unified Node Architecture"
content = """
Everything is a MessageNode - enabling seamless composition:

- Native LLM agents
- ACP-wrapped external agents
- Teams (parallel and sequential)
- Human-in-the-loop nodes
- Callable-based nodes
- All nodes share the same interface
- Connect any node to any other node
- Uniform monitoring and logging across all node types
"""

[step_5]
label = "Pool-Based Architecture"
content = """
Central coordination point for multi-agent systems:

- Type-safe dependency injection
- Shared resource management
- Session and history management
- Dynamic agent/team creation and cloning
- Agent discovery and access control
- Central monitoring and statistics
- Common storage configuration
"""

[step_6]
label = "Type-Safety on Pydantic-Level"
content = """
- Excellently typed user APIs
- Attention to detail for maximum type safety
- Type-safe message passing
- Type-safe agent-team forming
- Type-safe task execution
- Structured response handling
- Flexible routing options
- Cost and token tracking
"""

[step_7]
label = "Teams and Execution"
content = """
Flexible team operations and execution patterns:

- Parallel execution (agent1 & agent2)
- Sequential pipelines (agent1 | agent2)
- Rich monitoring capabilities
- Connection mechanisms (>>, &, |)
- Type-safe team creation
- Execution statistics and cost tracking
- Background execution with monitoring
"""

[step_8]
label = "MCP Server Integration"
content = """
Full Model Context Protocol support:

- Agents connect to MCP servers on async initialization
- MCP servers provide tools to agents
- Support for stdio, SSE, and HTTP transports
- Automatic tool discovery and registration
- Resource and prompt template support
"""

[step_9]
label = "Event System"
content = """
React to changes and automate workflows:

- File system monitoring with patterns
- Webhook endpoints
- Configurable event debouncing
- Event filtering and routing
- Custom trigger types
- Automatic context loading
- Event-driven agent execution
"""

[step_10]
label = "Command System"
content = """
Rich command system across all interfaces:

- Unified slash command system
- Tool management commands
- Resource inspection
- Model configuration
- History access and search
- Runtime configuration
- Session management
- Cross-interface consistency
"""

[step_11]
label = "Database & Logging"
content = """
Comprehensive interaction tracking:

- Multiple storage providers (SQL, file, memory)
- Configurable logging levels
- Message history tracking
- Flexible conversation formatting
- Tool usage monitoring
- Cost and token tracking
- Query capabilities
- Session recovery
- Sophisticated conversation filtering
"""

[step_12]
label = "Interaction Patterns"
content = """
Rich patterns for agent interaction and collaboration:

- Automatic and human-in-the-loop decisions
- Concurrent agent execution
- Non-blocking forwarding mechanisms
- Blocking when needed (await_response)
- Automatic result routing (>>)
- Team formation helpers
- Message broadcasting
- Connection monitoring
"""

[step_13]
label = "Multi-modal Support"
content = """
Rich content type support depending on model capabilities:

- Image input
- Audio input
- PDF and document processing
- Automatic content conversion
- Extensible converter system
"""

[step_14]
label = "Task System"
content = """
Independent work definitions with type safety:

- Tasks define requirements, not implementations
- Type-safe dependency requirements
- Automatic tool provisioning
- Knowledge source integration
- Runtime validation
- Reusable task definitions
- YAML-based task configuration
"""

[step_15]
label = "Knowledge Management"
content = """
Comprehensive knowledge integration:

- Multiple knowledge sources
- Rich resource handling
- Dynamic prompt integration
- Automatic context loading
- Markdown conversion
- Token-aware context management
- Parallel resource initialization
"""
