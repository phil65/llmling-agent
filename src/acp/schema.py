# generated by datamodel-codegen:
#   filename:  schema.json
#   timestamp: 2025-09-28T00:22:15+00:00

from __future__ import annotations

from collections.abc import Sequence
from typing import Any, Literal

from pydantic import BaseModel, ConfigDict, Field, RootModel, conint


class AuthenticateRequest(BaseModel):
    """
    Request parameters for the authenticate method.

    Specifies which authentication method to use.
    """

    model_config = ConfigDict(
        populate_by_name=True,
    )
    field_meta: Any | None = Field(
        None, alias="_meta", description="Extension point for implementations"
    )
    method_id: str = Field(
        ...,
        alias="methodId",
        description="The ID of the authentication method to use.\nMust be one of the methods advertised in the initialize response.",
    )


class AuthenticateResponse(BaseModel):
    """
    Response to authenticate method
    """

    model_config = ConfigDict(
        populate_by_name=True,
    )
    field_meta: Any | None = Field(
        None, alias="_meta", description="Extension point for implementations"
    )


class CommandInputHint(BaseModel):
    """
    All text that was typed after the command name is provided as input.
    """

    model_config = ConfigDict(
        populate_by_name=True,
    )
    hint: str = Field(
        ..., description="A hint to display when the input hasn't been provided yet"
    )


class AvailableCommandInput(RootModel[CommandInputHint]):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    root: CommandInputHint = Field(
        ..., description="The input specification for a command."
    )


class BlobResourceContents(BaseModel):
    """
    Binary resource contents.
    """

    model_config = ConfigDict(
        populate_by_name=True,
    )
    field_meta: Any | None = Field(
        None, alias="_meta", description="Extension point for implementations"
    )
    blob: str
    mime_type: str | None = Field(None, alias="mimeType")
    uri: str


class CreateTerminalResponse(BaseModel):
    """
    Response containing the ID of the created terminal.
    """

    model_config = ConfigDict(
        populate_by_name=True,
    )
    field_meta: Any | None = Field(
        None, alias="_meta", description="Extension point for implementations"
    )
    terminal_id: str = Field(
        ...,
        alias="terminalId",
        description="The unique identifier for the created terminal.",
    )


class EnvVariable(BaseModel):
    """
    An environment variable to set when launching an MCP server.
    """

    model_config = ConfigDict(
        populate_by_name=True,
    )
    field_meta: Any | None = Field(
        None, alias="_meta", description="Extension point for implementations"
    )
    name: str = Field(..., description="The name of the environment variable.")
    value: str = Field(..., description="The value to set for the environment variable.")


class FileSystemCapability(BaseModel):
    """
    File system capabilities that a client may support.

    See protocol docs: [FileSystem](https://agentclientprotocol.com/protocol/initialization#filesystem)
    """

    model_config = ConfigDict(
        populate_by_name=True,
    )
    field_meta: Any | None = Field(
        None, alias="_meta", description="Extension point for implementations"
    )
    read_text_file: bool | None = Field(
        False,
        alias="readTextFile",
        description="Whether the Client supports `fs/read_text_file` requests.",
    )
    write_text_file: bool | None = Field(
        False,
        alias="writeTextFile",
        description="Whether the Client supports `fs/write_text_file` requests.",
    )


class HttpHeader(BaseModel):
    """
    An HTTP header to set when making requests to the MCP server.
    """

    model_config = ConfigDict(
        populate_by_name=True,
    )
    field_meta: Any | None = Field(
        None, alias="_meta", description="Extension point for implementations"
    )
    name: str = Field(..., description="The name of the HTTP header.")
    value: str = Field(..., description="The value to set for the HTTP header.")


class KillTerminalCommandResponse(BaseModel):
    """
    Response to terminal/kill command method
    """

    model_config = ConfigDict(
        populate_by_name=True,
    )
    field_meta: Any | None = Field(
        None, alias="_meta", description="Extension point for implementations"
    )


class McpCapabilities(BaseModel):
    """
    MCP capabilities supported by the agent
    """

    model_config = ConfigDict(
        populate_by_name=True,
    )
    field_meta: Any | None = Field(
        None, alias="_meta", description="Extension point for implementations"
    )
    http: bool | None = Field(False, description="Agent supports [`McpServer::Http`].")
    sse: bool | None = Field(False, description="Agent supports [`McpServer::Sse`].")


class HttpMcpServer(BaseModel):
    """
    HTTP transport configuration

    Only available when the Agent capabilities indicate `mcp_capabilities.http` is `true`.
    """

    model_config = ConfigDict(
        populate_by_name=True,
    )
    headers: Sequence[HttpHeader] = Field(
        ..., description="HTTP headers to set when making requests to the MCP server."
    )
    name: str = Field(..., description="Human-readable name identifying this MCP server.")
    type: Literal["http"] = "http"
    url: str = Field(..., description="URL to the MCP server.")


class SseMcpServer(BaseModel):
    """
    SSE transport configuration

    Only available when the Agent capabilities indicate `mcp_capabilities.sse` is `true`.
    """

    model_config = ConfigDict(
        populate_by_name=True,
    )
    headers: Sequence[HttpHeader] = Field(
        ..., description="HTTP headers to set when making requests to the MCP server."
    )
    name: str = Field(..., description="Human-readable name identifying this MCP server.")
    type: Literal["sse"] = "sse"
    url: str = Field(..., description="URL to the MCP server.")


class StdioMcpServer(BaseModel):
    """
    Stdio transport configuration

    All Agents MUST support this transport.
    """

    model_config = ConfigDict(
        populate_by_name=True,
    )
    args: Sequence[str] = Field(
        ..., description="Command-line arguments to pass to the MCP server."
    )
    command: str = Field(..., description="Path to the MCP server executable.")
    env: Sequence[EnvVariable] = Field(
        ..., description="Environment variables to set when launching the MCP server."
    )
    name: str = Field(..., description="Human-readable name identifying this MCP server.")


class ModelInfo(BaseModel):
    """
    **UNSTABLE**

    This capability is not part of the spec yet, and may be removed or changed at any point.

    Information about a selectable model.
    """

    model_config = ConfigDict(
        populate_by_name=True,
    )
    field_meta: Any | None = Field(
        None, alias="_meta", description="Extension point for implementations"
    )
    description: str | None = Field(
        None, description="Optional description of the model."
    )
    model_id: str = Field(
        ..., alias="modelId", description="Unique identifier for the model."
    )
    name: str = Field(..., description="Human-readable name of the model.")


class NewSessionRequest(BaseModel):
    """
    Request parameters for creating a new session.

    See protocol docs: [Creating a Session](https://agentclientprotocol.com/protocol/session-setup#creating-a-session)
    """

    model_config = ConfigDict(
        populate_by_name=True,
    )
    field_meta: Any | None = Field(
        None, alias="_meta", description="Extension point for implementations"
    )
    cwd: str = Field(
        ...,
        description="The working directory for this session. Must be an absolute path.",
    )
    mcp_servers: Sequence[HttpMcpServer | SseMcpServer | StdioMcpServer] = Field(
        ...,
        alias="mcpServers",
        description="List of MCP (Model Context Protocol) servers the agent should connect to.",
    )


class PromptCapabilities(BaseModel):
    """
    Prompt capabilities supported by the agent in `session/prompt` requests.

    Baseline agent functionality requires support for [`ContentBlock::Text`]
    and [`ContentBlock::ResourceLink`] in prompt requests.

    Other variants must be explicitly opted in to.
    Capabilities for different types of content in prompt requests.

    Indicates which content types beyond the baseline (text and resource links)
    the agent can process.

    See protocol docs: [Prompt Capabilities](https://agentclientprotocol.com/protocol/initialization#prompt-capabilities)
    """

    model_config = ConfigDict(
        populate_by_name=True,
    )
    field_meta: Any | None = Field(
        None, alias="_meta", description="Extension point for implementations"
    )
    audio: bool | None = Field(
        False, description="Agent supports [`ContentBlock::Audio`]."
    )
    embedded_context: bool | None = Field(
        False,
        alias="embeddedContext",
        description="Agent supports embedded context in `session/prompt` requests.\n\nWhen enabled, the Client is allowed to include [`ContentBlock::Resource`]\nin prompt requests for pieces of context that are referenced in the message.",
    )
    image: bool | None = Field(
        False, description="Agent supports [`ContentBlock::Image`]."
    )


class ReadTextFileResponse(BaseModel):
    """
    Response containing the contents of a text file.
    """

    model_config = ConfigDict(
        populate_by_name=True,
    )
    field_meta: Any | None = Field(
        None, alias="_meta", description="Extension point for implementations"
    )
    content: str


class ReleaseTerminalResponse(BaseModel):
    """
    Response to terminal/release method
    """

    model_config = ConfigDict(
        populate_by_name=True,
    )
    field_meta: Any | None = Field(
        None, alias="_meta", description="Extension point for implementations"
    )


class DeniedOutcome(BaseModel):
    """
    The prompt turn was cancelled before the user responded.

    When a client sends a `session/cancel` notification to cancel an ongoing
    prompt turn, it MUST respond to all pending `session/request_permission`
    requests with this `Cancelled` outcome.

    See protocol docs: [Cancellation](https://agentclientprotocol.com/protocol/prompt-turn#cancellation)
    """

    model_config = ConfigDict(
        populate_by_name=True,
    )
    outcome: Literal["cancelled"] = "cancelled"


class AllowedOutcome(BaseModel):
    """
    The user selected one of the provided options.
    """

    model_config = ConfigDict(
        populate_by_name=True,
    )
    option_id: str = Field(
        ..., alias="optionId", description="The ID of the option the user selected."
    )
    outcome: Literal["selected"] = "selected"


class RequestPermissionResponse(BaseModel):
    """
    Response to a permission request.
    """

    model_config = ConfigDict(
        populate_by_name=True,
    )
    field_meta: Any | None = Field(
        None, alias="_meta", description="Extension point for implementations"
    )
    outcome: DeniedOutcome | AllowedOutcome = Field(
        ..., description="The user's decision on the permission request."
    )


class SessionModelState(BaseModel):
    """
    **UNSTABLE**

    This capability is not part of the spec yet, and may be removed or changed at any point.

    The set of models and the one currently active.
    """

    model_config = ConfigDict(
        populate_by_name=True,
    )
    field_meta: Any | None = Field(
        None, alias="_meta", description="Extension point for implementations"
    )
    available_models: Sequence[ModelInfo] = Field(
        ...,
        alias="availableModels",
        description="The set of models that the Agent can use",
    )
    current_model_id: str = Field(
        ..., alias="currentModelId", description="The current model the Agent is in."
    )


class CurrentModeUpdate(BaseModel):
    """
    The current mode of the session has changed

    See protocol docs: [Session Modes](https://agentclientprotocol.com/protocol/session-modes)
    """

    model_config = ConfigDict(
        populate_by_name=True,
    )
    current_mode_id: str = Field(
        ..., alias="currentModeId", description="Unique identifier for a Session Mode."
    )
    session_update: Literal["current_mode_update"] = Field(
        "current_mode_update", alias="sessionUpdate"
    )


class SetSessionModeRequest(BaseModel):
    """
    Request parameters for setting a session mode.
    """

    model_config = ConfigDict(
        populate_by_name=True,
    )
    field_meta: Any | None = Field(
        None, alias="_meta", description="Extension point for implementations"
    )
    mode_id: str = Field(..., alias="modeId", description="The ID of the mode to set.")
    session_id: str = Field(
        ..., alias="sessionId", description="The ID of the session to set the mode for."
    )


class SetSessionModeResponse(BaseModel):
    """
    Response to `session/set_mode` method.
    """

    model_config = ConfigDict(
        populate_by_name=True,
    )
    meta: Any | None = None


class SetSessionModelRequest(BaseModel):
    """
    **UNSTABLE**

    This capability is not part of the spec yet, and may be removed or changed at any point.

    Request parameters for setting a session model.
    """

    model_config = ConfigDict(
        populate_by_name=True,
    )
    field_meta: Any | None = Field(
        None, alias="_meta", description="Extension point for implementations"
    )
    model_id: str = Field(..., alias="modelId", description="The ID of the model to set.")
    session_id: str = Field(
        ...,
        alias="sessionId",
        description="The ID of the session to set the model for.",
    )


class SetSessionModelResponse(BaseModel):
    """
    **UNSTABLE**

    This capability is not part of the spec yet, and may be removed or changed at any point.

    Response to `session/set_model` method.
    """

    model_config = ConfigDict(
        populate_by_name=True,
    )
    field_meta: Any | None = Field(
        None, alias="_meta", description="Extension point for implementations"
    )


class TerminalExitStatus(BaseModel):
    """
    Exit status of a terminal command.
    """

    model_config = ConfigDict(
        populate_by_name=True,
    )
    field_meta: Any | None = Field(
        None, alias="_meta", description="Extension point for implementations"
    )
    exit_code: conint(ge=0) | None = Field(
        None,
        alias="exitCode",
        description="The process exit code (may be null if terminated by signal).",
    )
    signal: str | None = Field(
        None,
        description="The signal that terminated the process (may be null if exited normally).",
    )


class TerminalOutputRequest(BaseModel):
    """
    Request to get the current output and status of a terminal.
    """

    model_config = ConfigDict(
        populate_by_name=True,
    )
    field_meta: Any | None = Field(
        None, alias="_meta", description="Extension point for implementations"
    )
    session_id: str = Field(
        ..., alias="sessionId", description="The session ID for this request."
    )
    terminal_id: str = Field(
        ...,
        alias="terminalId",
        description="The ID of the terminal to get output from.",
    )


class TerminalOutputResponse(BaseModel):
    """
    Response containing the terminal output and exit status.
    """

    model_config = ConfigDict(
        populate_by_name=True,
    )
    field_meta: Any | None = Field(
        None, alias="_meta", description="Extension point for implementations"
    )
    exit_status: TerminalExitStatus | None = Field(
        None,
        alias="exitStatus",
        description="Exit status if the command has completed.",
    )
    output: str = Field(..., description="The terminal output captured so far.")
    truncated: bool = Field(
        ..., description="Whether the output was truncated due to byte limits."
    )


class TextResourceContents(BaseModel):
    """
    Text-based resource contents.
    """

    model_config = ConfigDict(
        populate_by_name=True,
    )
    field_meta: Any | None = Field(
        None, alias="_meta", description="Extension point for implementations"
    )
    mime_type: str | None = Field(None, alias="mimeType")
    text: str
    uri: str


class FileEditToolCallContent(BaseModel):
    """
    File modification shown as a diff.
    """

    model_config = ConfigDict(
        populate_by_name=True,
    )
    field_meta: Any | None = Field(
        None, alias="_meta", description="Extension point for implementations"
    )
    new_text: str = Field(
        ..., alias="newText", description="The new content after modification."
    )
    old_text: str | None = Field(
        None, alias="oldText", description="The original content (None for new files)."
    )
    path: str = Field(..., description="The file path being modified.")
    type: Literal["diff"] = "diff"


class TerminalToolCallContent(BaseModel):
    """
    Embed a terminal created with `terminal/create` by its id.

    The terminal must be added before calling `terminal/release`.

    See protocol docs: [Terminal](https://agentclientprotocol.com/protocol/terminal)
    """

    model_config = ConfigDict(
        populate_by_name=True,
    )
    terminal_id: str = Field(..., alias="terminalId")
    type: Literal["terminal"] = "terminal"


class ToolCallLocation(BaseModel):
    """
    A file location being accessed or modified by a tool.

    Enables clients to implement "follow-along" features that track
    which files the agent is working with in real-time.

    See protocol docs: [Following the Agent](https://agentclientprotocol.com/protocol/tool-calls#following-the-agent)
    """

    model_config = ConfigDict(
        populate_by_name=True,
    )
    field_meta: Any | None = Field(
        None, alias="_meta", description="Extension point for implementations"
    )
    line: conint(ge=0) | None = Field(
        None, description="Optional line number within the file."
    )
    path: str = Field(..., description="The file path being accessed or modified.")


class WaitForTerminalExitRequest(BaseModel):
    """
    Request to wait for a terminal command to exit.
    """

    model_config = ConfigDict(
        populate_by_name=True,
    )
    field_meta: Any | None = Field(
        None, alias="_meta", description="Extension point for implementations"
    )
    session_id: str = Field(
        ..., alias="sessionId", description="The session ID for this request."
    )
    terminal_id: str = Field(
        ..., alias="terminalId", description="The ID of the terminal to wait for."
    )


class WaitForTerminalExitResponse(BaseModel):
    """
    Response containing the exit status of a terminal command.
    """

    model_config = ConfigDict(
        populate_by_name=True,
    )
    field_meta: Any | None = Field(
        None, alias="_meta", description="Extension point for implementations"
    )
    exit_code: conint(ge=0) | None = Field(
        None,
        alias="exitCode",
        description="The process exit code (may be null if terminated by signal).",
    )
    signal: str | None = Field(
        None,
        description="The signal that terminated the process (may be null if exited normally).",
    )


class WriteTextFileRequest(BaseModel):
    """
    Request to write content to a text file.

    Only available if the client supports the `fs.writeTextFile` capability.
    """

    model_config = ConfigDict(
        populate_by_name=True,
    )
    field_meta: Any | None = Field(
        None, alias="_meta", description="Extension point for implementations"
    )
    content: str = Field(..., description="The text content to write to the file.")
    path: str = Field(..., description="Absolute path to the file to write.")
    session_id: str = Field(
        ..., alias="sessionId", description="The session ID for this request."
    )


class WriteTextFileResponse(BaseModel):
    """
    Response to `fs/write_text_file`
    """

    model_config = ConfigDict(
        populate_by_name=True,
    )
    field_meta: Any | None = Field(
        None, alias="_meta", description="Extension point for implementations"
    )


class AgentCapabilities(BaseModel):
    """
    Capabilities supported by the agent.

    Advertised during initialization to inform the client about
    available features and content types.

    See protocol docs: [Agent Capabilities](https://agentclientprotocol.com/protocol/initialization#agent-capabilities)
    """

    model_config = ConfigDict(
        populate_by_name=True,
    )
    field_meta: Any | None = Field(
        None, alias="_meta", description="Extension point for implementations"
    )
    load_session: bool | None = Field(
        False,
        alias="loadSession",
        description="Whether the agent supports `session/load`.",
    )
    mcp_capabilities: McpCapabilities | None = Field(
        default_factory=lambda: McpCapabilities.model_validate({
            "http": False,
            "sse": False,
        }),
        alias="mcpCapabilities",
        description="MCP capabilities supported by the agent.",
    )
    prompt_capabilities: PromptCapabilities | None = Field(
        default_factory=lambda: PromptCapabilities.model_validate({
            "audio": False,
            "embeddedContext": False,
            "image": False,
        }),
        alias="promptCapabilities",
        description="Prompt capabilities supported by the agent.",
    )


class Annotations(BaseModel):
    """
    Optional annotations for the client. The client can use annotations to inform how objects are used or displayed
    """

    model_config = ConfigDict(
        populate_by_name=True,
    )
    field_meta: Any | None = Field(
        None, alias="_meta", description="Extension point for implementations"
    )
    audience: Sequence[Literal["assistant", "user"]] | None = None
    last_modified: str | None = Field(None, alias="lastModified")
    priority: float | None = None


class AudioContent(BaseModel):
    """
    Audio provided to or from an LLM.
    """

    model_config = ConfigDict(
        populate_by_name=True,
    )
    field_meta: Any | None = Field(
        None, alias="_meta", description="Extension point for implementations"
    )
    annotations: Annotations | None = None
    data: str
    mime_type: str = Field(..., alias="mimeType")


class AuthMethod(BaseModel):
    """
    Describes an available authentication method.
    """

    model_config = ConfigDict(
        populate_by_name=True,
    )
    field_meta: Any | None = Field(
        None, alias="_meta", description="Extension point for implementations"
    )
    description: str | None = Field(
        None,
        description="Optional description providing more details about this authentication method.",
    )
    id: str = Field(..., description="Unique identifier for this authentication method.")
    name: str = Field(
        ..., description="Human-readable name of the authentication method."
    )


class AvailableCommand(BaseModel):
    """
    Information about a command.
    """

    model_config = ConfigDict(
        populate_by_name=True,
    )
    field_meta: Any | None = Field(
        None, alias="_meta", description="Extension point for implementations"
    )
    description: str = Field(
        ..., description="Human-readable description of what the command does."
    )
    input: AvailableCommandInput | None = Field(
        None, description="Input for the command if required"
    )
    name: str = Field(
        ..., description="Command name (e.g., `create_plan`, `research_codebase`)."
    )


class CancelNotification(BaseModel):
    """
    Notification to cancel ongoing operations for a session.

    See protocol docs: [Cancellation](https://agentclientprotocol.com/protocol/prompt-turn#cancellation)
    """

    model_config = ConfigDict(
        populate_by_name=True,
    )
    field_meta: Any | None = Field(
        None, alias="_meta", description="Extension point for implementations"
    )
    session_id: str = Field(
        ...,
        alias="sessionId",
        description="The ID of the session to cancel operations for.",
    )


class ClientCapabilities(BaseModel):
    """
    Capabilities supported by the client.

    Advertised during initialization to inform the agent about
    available features and methods.

    See protocol docs: [Client Capabilities](https://agentclientprotocol.com/protocol/initialization#client-capabilities)
    """

    model_config = ConfigDict(
        populate_by_name=True,
    )
    field_meta: Any | None = Field(
        None, alias="_meta", description="Extension point for implementations"
    )
    fs: FileSystemCapability | None = Field(
        default_factory=lambda: FileSystemCapability.model_validate({
            "readTextFile": False,
            "writeTextFile": False,
        }),
        description="File system capabilities supported by the client.\nDetermines which file operations the agent can request.",
    )
    terminal: bool | None = Field(
        False, description="Whether the Client support all `terminal/*` methods."
    )


class TextContentBlock(BaseModel):
    """
    Plain text content

    All agents MUST support text content blocks in prompts.
    """

    model_config = ConfigDict(
        populate_by_name=True,
    )
    field_meta: Any | None = Field(
        None, alias="_meta", description="Extension point for implementations"
    )
    annotations: Annotations | None = None
    text: str
    type: Literal["text"] = "text"


class ImageContentBlock(BaseModel):
    """
    Images for visual context or analysis.

    Requires the `image` prompt capability when included in prompts.
    """

    model_config = ConfigDict(
        populate_by_name=True,
    )
    field_meta: Any | None = Field(
        None, alias="_meta", description="Extension point for implementations"
    )
    annotations: Annotations | None = None
    data: str
    mime_type: str = Field(..., alias="mimeType")
    type: Literal["image"] = "image"
    uri: str | None = None


class AudioContentBlock(BaseModel):
    """
    Audio data for transcription or analysis.

    Requires the `audio` prompt capability when included in prompts.
    """

    model_config = ConfigDict(
        populate_by_name=True,
    )
    field_meta: Any | None = Field(
        None, alias="_meta", description="Extension point for implementations"
    )
    annotations: Annotations | None = None
    data: str
    mime_type: str = Field(..., alias="mimeType")
    type: Literal["audio"] = "audio"


class ResourceContentBlock(BaseModel):
    """
    References to resources that the agent can access.

    All agents MUST support resource links in prompts.
    """

    model_config = ConfigDict(
        populate_by_name=True,
    )
    field_meta: Any | None = Field(
        None, alias="_meta", description="Extension point for implementations"
    )
    annotations: Annotations | None = None
    description: str | None = None
    mime_type: str | None = Field(None, alias="mimeType")
    name: str
    size: int | None = None
    title: str | None = None
    type: Literal["resource_link"] = "resource_link"
    uri: str


class CreateTerminalRequest(BaseModel):
    """
    Request to create a new terminal and execute a command.
    """

    model_config = ConfigDict(
        populate_by_name=True,
    )
    field_meta: Any | None = Field(
        None, alias="_meta", description="Extension point for implementations"
    )
    args: Sequence[str] | None = Field(None, description="Array of command arguments.")
    command: str = Field(..., description="The command to execute.")
    cwd: str | None = Field(
        None, description="Working directory for the command (absolute path)."
    )
    env: Sequence[EnvVariable] | None = Field(
        None, description="Environment variables for the command."
    )
    output_byte_limit: conint(ge=0) | None = Field(
        None,
        alias="outputByteLimit",
        description="Maximum number of output bytes to retain.\n\nWhen the limit is exceeded, the Client truncates from the beginning of the output\nto stay within the limit.\n\nThe Client MUST ensure truncation happens at a character boundary to maintain valid\nstring output, even if this means the retained output is slightly less than the\nspecified limit.",
    )
    session_id: str = Field(
        ..., alias="sessionId", description="The session ID for this request."
    )


class ImageContent(BaseModel):
    """
    An image provided to or from an LLM.
    """

    model_config = ConfigDict(
        populate_by_name=True,
    )
    field_meta: Any | None = Field(
        None, alias="_meta", description="Extension point for implementations"
    )
    annotations: Annotations | None = None
    data: str
    mime_type: str = Field(..., alias="mimeType")
    uri: str | None = None


class InitializeRequest(BaseModel):
    """
    Request parameters for the initialize method.

    Sent by the client to establish connection and negotiate capabilities.

    See protocol docs: [Initialization](https://agentclientprotocol.com/protocol/initialization)
    """

    model_config = ConfigDict(
        populate_by_name=True,
    )
    field_meta: Any | None = Field(
        None, alias="_meta", description="Extension point for implementations"
    )
    client_capabilities: ClientCapabilities | None = Field(
        default_factory=lambda: ClientCapabilities.model_validate({
            "fs": {"readTextFile": False, "writeTextFile": False},
            "terminal": False,
        }),
        alias="clientCapabilities",
        description="Capabilities supported by the client.",
    )
    protocol_version: conint(ge=0, le=65535) = Field(
        ...,
        alias="protocolVersion",
        description="The latest protocol version supported by the client.",
    )


class InitializeResponse(BaseModel):
    """
    Response from the initialize method.

    Contains the negotiated protocol version and agent capabilities.

    See protocol docs: [Initialization](https://agentclientprotocol.com/protocol/initialization)
    """

    model_config = ConfigDict(
        populate_by_name=True,
    )
    field_meta: Any | None = Field(
        None, alias="_meta", description="Extension point for implementations"
    )
    agent_capabilities: AgentCapabilities | None = Field(
        default_factory=lambda: AgentCapabilities.model_validate({
            "loadSession": False,
            "mcpCapabilities": {"http": False, "sse": False},
            "promptCapabilities": {
                "audio": False,
                "embeddedContext": False,
                "image": False,
            },
        }),
        alias="agentCapabilities",
        description="Capabilities supported by the agent.",
    )
    auth_methods: Sequence[AuthMethod] | None = Field(
        [],
        alias="authMethods",
        description="Authentication methods supported by the agent.",
    )
    protocol_version: conint(ge=0, le=65535) = Field(
        ...,
        alias="protocolVersion",
        description="The protocol version the client specified if supported by the agent,\nor the latest protocol version supported by the agent.\n\nThe client should disconnect, if it doesn't support this version.",
    )


class KillTerminalCommandRequest(BaseModel):
    """
    Request to kill a terminal command without releasing the terminal.
    """

    model_config = ConfigDict(
        populate_by_name=True,
    )
    field_meta: Any | None = Field(
        None, alias="_meta", description="Extension point for implementations"
    )
    session_id: str = Field(
        ..., alias="sessionId", description="The session ID for this request."
    )
    terminal_id: str = Field(
        ..., alias="terminalId", description="The ID of the terminal to kill."
    )


class LoadSessionRequest(BaseModel):
    """
    Request parameters for loading an existing session.

    Only available if the Agent supports the `loadSession` capability.

    See protocol docs: [Loading Sessions](https://agentclientprotocol.com/protocol/session-setup#loading-sessions)
    """

    model_config = ConfigDict(
        populate_by_name=True,
    )
    field_meta: Any | None = Field(
        None, alias="_meta", description="Extension point for implementations"
    )
    cwd: str = Field(..., description="The working directory for this session.")
    mcp_servers: Sequence[HttpMcpServer | SseMcpServer | StdioMcpServer] = Field(
        ...,
        alias="mcpServers",
        description="List of MCP servers to connect to for this session.",
    )
    session_id: str = Field(
        ..., alias="sessionId", description="The ID of the session to load."
    )


class PermissionOption(BaseModel):
    """
    An option presented to the user when requesting permission.
    """

    model_config = ConfigDict(
        populate_by_name=True,
    )
    field_meta: Any | None = Field(
        None, alias="_meta", description="Extension point for implementations"
    )
    kind: Literal["allow_once", "allow_always", "reject_once", "reject_always"] = Field(
        ..., description="Hint about the nature of this permission option."
    )
    name: str = Field(..., description="Human-readable label to display to the user.")
    option_id: str = Field(
        ...,
        alias="optionId",
        description="Unique identifier for this permission option.",
    )


class PlanEntry(BaseModel):
    """
    A single entry in the execution plan.

    Represents a task or goal that the assistant intends to accomplish
    as part of fulfilling the user's request.
    See protocol docs: [Plan Entries](https://agentclientprotocol.com/protocol/agent-plan#plan-entries)
    """

    model_config = ConfigDict(
        populate_by_name=True,
    )
    field_meta: Any | None = Field(
        None, alias="_meta", description="Extension point for implementations"
    )
    content: str = Field(
        ...,
        description="Human-readable description of what this task aims to accomplish.",
    )
    priority: Literal["high", "medium", "low"] = Field(
        ...,
        description="The relative importance of this task.\nUsed to indicate which tasks are most critical to the overall goal.",
    )
    status: Literal["pending", "in_progress", "completed"] = Field(
        ..., description="Current execution status of this task."
    )


class PromptResponse(BaseModel):
    """
    Response from processing a user prompt.

    See protocol docs: [Check for Completion](https://agentclientprotocol.com/protocol/prompt-turn#4-check-for-completion)
    """

    model_config = ConfigDict(
        populate_by_name=True,
    )
    field_meta: Any | None = Field(
        None, alias="_meta", description="Extension point for implementations"
    )
    stop_reason: Literal[
        "end_turn", "max_tokens", "max_turn_requests", "refusal", "cancelled"
    ] = Field(
        ...,
        alias="stopReason",
        description="Indicates why the agent stopped processing the turn.",
    )


class ReadTextFileRequest(BaseModel):
    """
    Request to read content from a text file.

    Only available if the client supports the `fs.readTextFile` capability.
    """

    model_config = ConfigDict(
        populate_by_name=True,
    )
    field_meta: Any | None = Field(
        None, alias="_meta", description="Extension point for implementations"
    )
    limit: conint(ge=0) | None = Field(
        None, description="Maximum number of lines to read."
    )
    line: conint(ge=0) | None = Field(
        None, description="Line number to start reading from (1-based)."
    )
    path: str = Field(..., description="Absolute path to the file to read.")
    session_id: str = Field(
        ..., alias="sessionId", description="The session ID for this request."
    )


class ReleaseTerminalRequest(BaseModel):
    """
    Request to release a terminal and free its resources.
    """

    model_config = ConfigDict(
        populate_by_name=True,
    )
    field_meta: Any | None = Field(
        None, alias="_meta", description="Extension point for implementations"
    )
    session_id: str = Field(
        ..., alias="sessionId", description="The session ID for this request."
    )
    terminal_id: str = Field(
        ..., alias="terminalId", description="The ID of the terminal to release."
    )


class ResourceLink(BaseModel):
    """
    A resource that the server is capable of reading, included in a prompt or tool call result.
    """

    model_config = ConfigDict(
        populate_by_name=True,
    )
    field_meta: Any | None = Field(
        None, alias="_meta", description="Extension point for implementations"
    )
    annotations: Annotations | None = None
    description: str | None = None
    mime_type: str | None = Field(None, alias="mimeType")
    name: str
    size: int | None = None
    title: str | None = None
    uri: str


class SessionMode(BaseModel):
    """
    A mode the agent can operate in.

    See protocol docs: [Session Modes](https://agentclientprotocol.com/protocol/session-modes)
    """

    model_config = ConfigDict(
        populate_by_name=True,
    )
    field_meta: Any | None = Field(
        None, alias="_meta", description="Extension point for implementations"
    )
    description: str | None = None
    id: str = Field(..., description="Unique identifier for a Session Mode.")
    name: str


class SessionModeState(BaseModel):
    """
    The set of modes and the one currently active.
    """

    model_config = ConfigDict(
        populate_by_name=True,
    )
    field_meta: Any | None = Field(
        None, alias="_meta", description="Extension point for implementations"
    )
    available_modes: Sequence[SessionMode] = Field(
        ...,
        alias="availableModes",
        description="The set of modes that the Agent can operate in",
    )
    current_mode_id: str = Field(
        ..., alias="currentModeId", description="The current mode the Agent is in."
    )


class AgentPlan(BaseModel):
    """
    The agent's execution plan for complex tasks.
    See protocol docs: [Agent Plan](https://agentclientprotocol.com/protocol/agent-plan)
    """

    model_config = ConfigDict(
        populate_by_name=True,
    )
    field_meta: Any | None = Field(
        None, alias="_meta", description="Extension point for implementations"
    )
    entries: Sequence[PlanEntry] = Field(
        ...,
        description="The list of tasks to be accomplished.\n\nWhen updating a plan, the agent must send a complete list of all entries\nwith their current status. The client replaces the entire plan with each update.",
    )
    session_update: Literal["plan"] = Field("plan", alias="sessionUpdate")


class AvailableCommandsUpdate(BaseModel):
    """
    Available commands are ready or have changed
    """

    model_config = ConfigDict(
        populate_by_name=True,
    )
    available_commands: Sequence[AvailableCommand] = Field(..., alias="availableCommands")
    session_update: Literal["available_commands_update"] = Field(
        "available_commands_update", alias="sessionUpdate"
    )


class TextContent(BaseModel):
    """
    Text provided to or from an LLM.
    """

    model_config = ConfigDict(
        populate_by_name=True,
    )
    field_meta: Any | None = Field(
        None, alias="_meta", description="Extension point for implementations"
    )
    annotations: Annotations | None = None
    text: str


class EmbeddedResourceContentBlock(BaseModel):
    """
    Complete resource contents embedded directly in the message.

    Preferred for including context as it avoids extra round-trips.

    Requires the `embeddedContext` prompt capability when included in prompts.
    """

    model_config = ConfigDict(
        populate_by_name=True,
    )
    field_meta: Any | None = Field(
        None, alias="_meta", description="Extension point for implementations"
    )
    annotations: Annotations | None = None
    resource: TextResourceContents | BlobResourceContents = Field(
        ..., description="Resource content that can be embedded in a message."
    )
    type: Literal["resource"] = "resource"


class EmbeddedResource(BaseModel):
    """
    The contents of a resource, embedded into a prompt or tool call result.
    """

    model_config = ConfigDict(
        populate_by_name=True,
    )
    field_meta: Any | None = Field(
        None, alias="_meta", description="Extension point for implementations"
    )
    annotations: Annotations | None = None
    resource: TextResourceContents | BlobResourceContents = Field(
        ..., description="Resource content that can be embedded in a message."
    )


class LoadSessionResponse(BaseModel):
    """
    Response from loading an existing session.
    """

    model_config = ConfigDict(
        populate_by_name=True,
    )
    field_meta: Any | None = Field(
        None, alias="_meta", description="Extension point for implementations"
    )
    models: SessionModelState | None = Field(
        None,
        description="**UNSTABLE**\n\nThis capability is not part of the spec yet, and may be removed or changed at any point.\n\nInitial model state if supported by the Agent",
    )
    modes: SessionModeState | None = Field(
        None,
        description="Initial mode state if supported by the Agent\n\nSee protocol docs: [Session Modes](https://agentclientprotocol.com/protocol/session-modes)",
    )


class NewSessionResponse(BaseModel):
    """
    Response from creating a new session.

    See protocol docs: [Creating a Session](https://agentclientprotocol.com/protocol/session-setup#creating-a-session)
    """

    model_config = ConfigDict(
        populate_by_name=True,
    )
    field_meta: Any | None = Field(
        None, alias="_meta", description="Extension point for implementations"
    )
    models: SessionModelState | None = Field(
        None,
        description="**UNSTABLE**\n\nThis capability is not part of the spec yet, and may be removed or changed at any point.\n\nInitial model state if supported by the Agent",
    )
    modes: SessionModeState | None = Field(
        None,
        description="Initial mode state if supported by the Agent\n\nSee protocol docs: [Session Modes](https://agentclientprotocol.com/protocol/session-modes)",
    )
    session_id: str = Field(
        ...,
        alias="sessionId",
        description="Unique identifier for the created session.\n\nUsed in all subsequent requests for this conversation.",
    )


class Plan(BaseModel):
    """
    An execution plan for accomplishing complex tasks.

    Plans consist of multiple entries representing individual tasks or goals.
    Agents report plans to clients to provide visibility into their execution strategy.
    Plans can evolve during execution as the agent discovers new requirements or completes tasks.

    See protocol docs: [Agent Plan](https://agentclientprotocol.com/protocol/agent-plan)
    """

    model_config = ConfigDict(
        populate_by_name=True,
    )
    field_meta: Any | None = Field(
        None, alias="_meta", description="Extension point for implementations"
    )
    entries: Sequence[PlanEntry] = Field(
        ...,
        description="The list of tasks to be accomplished.\n\nWhen updating a plan, the agent must send a complete list of all entries\nwith their current status. The client replaces the entire plan with each update.",
    )


class PromptRequest(BaseModel):
    """
    Request parameters for sending a user prompt to the agent.

    Contains the user's message and any additional context.

    See protocol docs: [User Message](https://agentclientprotocol.com/protocol/prompt-turn#1-user-message)
    """

    model_config = ConfigDict(
        populate_by_name=True,
    )
    field_meta: Any | None = Field(
        None, alias="_meta", description="Extension point for implementations"
    )
    prompt: Sequence[
        TextContentBlock
        | ImageContentBlock
        | AudioContentBlock
        | ResourceContentBlock
        | EmbeddedResourceContentBlock
    ] = Field(
        ...,
        description="The blocks of content that compose the user's message.\n\nAs a baseline, the Agent MUST support [`ContentBlock::Text`] and [`ContentBlock::ResourceLink`],\nwhile other variants are optionally enabled via [`PromptCapabilities`].\n\nThe Client MUST adapt its interface according to [`PromptCapabilities`].\n\nThe client MAY include referenced pieces of context as either\n[`ContentBlock::Resource`] or [`ContentBlock::ResourceLink`].\n\nWhen available, [`ContentBlock::Resource`] is preferred\nas it avoids extra round-trips and allows the message to include\npieces of context from sources the agent may not have access to.",
    )
    session_id: str = Field(
        ...,
        alias="sessionId",
        description="The ID of the session to send this user message to",
    )


class UserMessageChunk(BaseModel):
    """
    A chunk of the user's message being streamed.
    """

    model_config = ConfigDict(
        populate_by_name=True,
    )
    content: (
        TextContentBlock
        | ImageContentBlock
        | AudioContentBlock
        | ResourceContentBlock
        | EmbeddedResourceContentBlock
    ) = Field(
        ...,
        description="Content blocks represent displayable information in the Agent Client Protocol.\n\nThey provide a structured way to handle various types of user-facing content—whether\nit's text from language models, images for analysis, or embedded resources for context.\n\nContent blocks appear in:\n- User prompts sent via `session/prompt`\n- Language model output streamed through `session/update` notifications\n- Progress updates and results from tool calls\n\nThis structure is compatible with the Model Context Protocol (MCP), enabling\nagents to seamlessly forward content from MCP tool outputs without transformation.\n\nSee protocol docs: [Content](https://agentclientprotocol.com/protocol/content)",
    )
    session_update: Literal["user_message_chunk"] = Field(
        "user_message_chunk", alias="sessionUpdate"
    )


class AgentMessageChunk(BaseModel):
    """
    A chunk of the agent's response being streamed.
    """

    model_config = ConfigDict(
        populate_by_name=True,
    )
    content: (
        TextContentBlock
        | ImageContentBlock
        | AudioContentBlock
        | ResourceContentBlock
        | EmbeddedResourceContentBlock
    ) = Field(
        ...,
        description="Content blocks represent displayable information in the Agent Client Protocol.\n\nThey provide a structured way to handle various types of user-facing content—whether\nit's text from language models, images for analysis, or embedded resources for context.\n\nContent blocks appear in:\n- User prompts sent via `session/prompt`\n- Language model output streamed through `session/update` notifications\n- Progress updates and results from tool calls\n\nThis structure is compatible with the Model Context Protocol (MCP), enabling\nagents to seamlessly forward content from MCP tool outputs without transformation.\n\nSee protocol docs: [Content](https://agentclientprotocol.com/protocol/content)",
    )
    session_update: Literal["agent_message_chunk"] = Field(
        "agent_message_chunk", alias="sessionUpdate"
    )


class AgentThoughtChunk(BaseModel):
    """
    A chunk of the agent's internal reasoning being streamed.
    """

    model_config = ConfigDict(
        populate_by_name=True,
    )
    content: (
        TextContentBlock
        | ImageContentBlock
        | AudioContentBlock
        | ResourceContentBlock
        | EmbeddedResourceContentBlock
    ) = Field(
        ...,
        description="Content blocks represent displayable information in the Agent Client Protocol.\n\nThey provide a structured way to handle various types of user-facing content—whether\nit's text from language models, images for analysis, or embedded resources for context.\n\nContent blocks appear in:\n- User prompts sent via `session/prompt`\n- Language model output streamed through `session/update` notifications\n- Progress updates and results from tool calls\n\nThis structure is compatible with the Model Context Protocol (MCP), enabling\nagents to seamlessly forward content from MCP tool outputs without transformation.\n\nSee protocol docs: [Content](https://agentclientprotocol.com/protocol/content)",
    )
    session_update: Literal["agent_thought_chunk"] = Field(
        "agent_thought_chunk", alias="sessionUpdate"
    )


class ContentToolCallContent(BaseModel):
    """
    Standard content block (text, images, resources).
    """

    model_config = ConfigDict(
        populate_by_name=True,
    )
    content: (
        TextContentBlock
        | ImageContentBlock
        | AudioContentBlock
        | ResourceContentBlock
        | EmbeddedResourceContentBlock
    ) = Field(..., description="The actual content block.")
    type: Literal["content"] = "content"


class ToolCallUpdate(BaseModel):
    """
    An update to an existing tool call.

    Used to report progress and results as tools execute. All fields except
    the tool call ID are optional - only changed fields need to be included.

    See protocol docs: [Updating](https://agentclientprotocol.com/protocol/tool-calls#updating)
    """

    model_config = ConfigDict(
        populate_by_name=True,
    )
    field_meta: Any | None = Field(
        None, alias="_meta", description="Extension point for implementations"
    )
    content: (
        Sequence[
            ContentToolCallContent | FileEditToolCallContent | TerminalToolCallContent
        ]
        | None
    ) = Field(None, description="Replace the content collection.")
    kind: (
        Literal[
            "read",
            "edit",
            "delete",
            "move",
            "search",
            "execute",
            "think",
            "fetch",
            "switch_mode",
            "other",
        ]
        | None
    ) = Field(None, description="Update the tool kind.")
    locations: Sequence[ToolCallLocation] | None = Field(
        None, description="Replace the locations collection."
    )
    raw_input: Any | None = Field(
        None, alias="rawInput", description="Update the raw input."
    )
    raw_output: Any | None = Field(
        None, alias="rawOutput", description="Update the raw output."
    )
    status: Literal["pending", "in_progress", "completed", "failed"] | None = Field(
        None, description="Update the execution status."
    )
    title: str | None = Field(None, description="Update the human-readable title.")
    tool_call_id: str = Field(
        ..., alias="toolCallId", description="The ID of the tool call being updated."
    )


class RequestPermissionRequest(BaseModel):
    """
    Request for user permission to execute a tool call.

    Sent when the agent needs authorization before performing a sensitive operation.

    See protocol docs: [Requesting Permission](https://agentclientprotocol.com/protocol/tool-calls#requesting-permission)
    """

    model_config = ConfigDict(
        populate_by_name=True,
    )
    field_meta: Any | None = Field(
        None, alias="_meta", description="Extension point for implementations"
    )
    options: Sequence[PermissionOption] = Field(
        ..., description="Available permission options for the user to choose from."
    )
    session_id: str = Field(
        ..., alias="sessionId", description="The session ID for this request."
    )
    tool_call: ToolCallUpdate = Field(
        ...,
        alias="toolCall",
        description="Details about the tool call requiring permission.",
    )


class ToolCallStart(BaseModel):
    """
    Notification that a new tool call has been initiated.
    """

    model_config = ConfigDict(
        populate_by_name=True,
    )
    field_meta: Any | None = Field(
        None, alias="_meta", description="Extension point for implementations"
    )
    content: (
        Sequence[
            ContentToolCallContent | FileEditToolCallContent | TerminalToolCallContent
        ]
        | None
    ) = Field(None, description="Content produced by the tool call.")
    kind: (
        Literal[
            "read",
            "edit",
            "delete",
            "move",
            "search",
            "execute",
            "think",
            "fetch",
            "switch_mode",
            "other",
        ]
        | None
    ) = Field(
        None,
        description="The category of tool being invoked.\nHelps clients choose appropriate icons and UI treatment.",
    )
    locations: Sequence[ToolCallLocation] | None = Field(
        None,
        description='File locations affected by this tool call.\nEnables "follow-along" features in clients.',
    )
    raw_input: Any | None = Field(
        None, alias="rawInput", description="Raw input parameters sent to the tool."
    )
    raw_output: Any | None = Field(
        None, alias="rawOutput", description="Raw output returned by the tool."
    )
    session_update: Literal["tool_call"] = Field("tool_call", alias="sessionUpdate")
    status: Literal["pending", "in_progress", "completed", "failed"] | None = Field(
        None, description="Current execution status of the tool call."
    )
    title: str = Field(
        ..., description="Human-readable title describing what the tool is doing."
    )
    tool_call_id: str = Field(
        ...,
        alias="toolCallId",
        description="Unique identifier for this tool call within the session.",
    )


class ToolCallProgress(BaseModel):
    """
    Update on the status or results of a tool call.
    """

    model_config = ConfigDict(
        populate_by_name=True,
    )
    field_meta: Any | None = Field(
        None, alias="_meta", description="Extension point for implementations"
    )
    content: (
        Sequence[
            ContentToolCallContent | FileEditToolCallContent | TerminalToolCallContent
        ]
        | None
    ) = Field(None, description="Replace the content collection.")
    kind: (
        Literal[
            "read",
            "edit",
            "delete",
            "move",
            "search",
            "execute",
            "think",
            "fetch",
            "switch_mode",
            "other",
        ]
        | None
    ) = Field(None, description="Update the tool kind.")
    locations: Sequence[ToolCallLocation] | None = Field(
        None, description="Replace the locations collection."
    )
    raw_input: Any | None = Field(
        None, alias="rawInput", description="Update the raw input."
    )
    raw_output: Any | None = Field(
        None, alias="rawOutput", description="Update the raw output."
    )
    session_update: Literal["tool_call_update"] = Field(
        "tool_call_update", alias="sessionUpdate"
    )
    status: Literal["pending", "in_progress", "completed", "failed"] | None = Field(
        None, description="Update the execution status."
    )
    title: str | None = Field(None, description="Update the human-readable title.")
    tool_call_id: str = Field(
        ..., alias="toolCallId", description="The ID of the tool call being updated."
    )


class ToolCall(BaseModel):
    """
    Represents a tool call that the language model has requested.

    Tool calls are actions that the agent executes on behalf of the language model,
    such as reading files, executing code, or fetching data from external sources.

    See protocol docs: [Tool Calls](https://agentclientprotocol.com/protocol/tool-calls)
    """

    model_config = ConfigDict(
        populate_by_name=True,
    )
    field_meta: Any | None = Field(
        None, alias="_meta", description="Extension point for implementations"
    )
    content: (
        Sequence[
            ContentToolCallContent | FileEditToolCallContent | TerminalToolCallContent
        ]
        | None
    ) = Field(None, description="Content produced by the tool call.")
    kind: (
        Literal[
            "read",
            "edit",
            "delete",
            "move",
            "search",
            "execute",
            "think",
            "fetch",
            "switch_mode",
            "other",
        ]
        | None
    ) = Field(
        None,
        description="The category of tool being invoked.\nHelps clients choose appropriate icons and UI treatment.",
    )
    locations: Sequence[ToolCallLocation] | None = Field(
        None,
        description='File locations affected by this tool call.\nEnables "follow-along" features in clients.',
    )
    raw_input: Any | None = Field(
        None, alias="rawInput", description="Raw input parameters sent to the tool."
    )
    raw_output: Any | None = Field(
        None, alias="rawOutput", description="Raw output returned by the tool."
    )
    status: Literal["pending", "in_progress", "completed", "failed"] | None = Field(
        None, description="Current execution status of the tool call."
    )
    title: str = Field(
        ..., description="Human-readable title describing what the tool is doing."
    )
    tool_call_id: str = Field(
        ...,
        alias="toolCallId",
        description="Unique identifier for this tool call within the session.",
    )


class SessionNotification(BaseModel):
    """
    Notification containing a session update from the agent.

    Used to stream real-time progress and results during prompt processing.

    See protocol docs: [Agent Reports Output](https://agentclientprotocol.com/protocol/prompt-turn#3-agent-reports-output)
    """

    model_config = ConfigDict(
        populate_by_name=True,
    )
    field_meta: Any | None = Field(
        None, alias="_meta", description="Extension point for implementations"
    )
    session_id: str = Field(
        ...,
        alias="sessionId",
        description="The ID of the session this update pertains to.",
    )
    update: (
        UserMessageChunk
        | AgentMessageChunk
        | AgentThoughtChunk
        | ToolCallStart
        | ToolCallProgress
        | AgentPlan
        | AvailableCommandsUpdate
        | CurrentModeUpdate
    ) = Field(..., description="The actual update content.")


class Model(
    RootModel[
        WriteTextFileRequest
        | ReadTextFileRequest
        | RequestPermissionRequest
        | CreateTerminalRequest
        | TerminalOutputRequest
        | ReleaseTerminalRequest
        | WaitForTerminalExitRequest
        | KillTerminalCommandRequest
        | Any
        | WriteTextFileResponse
        | ReadTextFileResponse
        | RequestPermissionResponse
        | CreateTerminalResponse
        | TerminalOutputResponse
        | ReleaseTerminalResponse
        | WaitForTerminalExitResponse
        | KillTerminalCommandResponse
        | Any
        | CancelNotification
        | Any
        | InitializeRequest
        | AuthenticateRequest
        | NewSessionRequest
        | LoadSessionRequest
        | SetSessionModeRequest
        | PromptRequest
        | SetSessionModelRequest
        | Any
        | InitializeResponse
        | AuthenticateResponse
        | NewSessionResponse
        | LoadSessionResponse
        | SetSessionModeResponse
        | PromptResponse
        | SetSessionModelResponse
        | Any
        | SessionNotification
        | Any
    ]
):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    root: (
        WriteTextFileRequest
        | ReadTextFileRequest
        | RequestPermissionRequest
        | CreateTerminalRequest
        | TerminalOutputRequest
        | ReleaseTerminalRequest
        | WaitForTerminalExitRequest
        | KillTerminalCommandRequest
        | Any
        | WriteTextFileResponse
        | ReadTextFileResponse
        | RequestPermissionResponse
        | CreateTerminalResponse
        | TerminalOutputResponse
        | ReleaseTerminalResponse
        | WaitForTerminalExitResponse
        | KillTerminalCommandResponse
        | Any
        | CancelNotification
        | Any
        | InitializeRequest
        | AuthenticateRequest
        | NewSessionRequest
        | LoadSessionRequest
        | SetSessionModeRequest
        | PromptRequest
        | SetSessionModelRequest
        | Any
        | InitializeResponse
        | AuthenticateResponse
        | NewSessionResponse
        | LoadSessionResponse
        | SetSessionModeResponse
        | PromptResponse
        | SetSessionModelResponse
        | Any
        | SessionNotification
        | Any
    )
